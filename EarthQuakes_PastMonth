import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D # module that gives matplotlib the ability to do 3D. Axes3D is the class that creates a 3D axis system
from matplotlib import cm # cm is colormap, a module that contains a set of predefined colormaps that can be used to map data values to colors in visualizations
import matplotlib.gridspec as gridspec #helps lay out subplots with flexible row/column sizes different from each other
import matplotlib as mpl
from matplotlib import rc, rcParams # global style setting for plots
import pandas as pd
import numpy as np
from scipy.interpolate import griddata, LinearNDInterpolator
import plotly.graph_objects as go
from scipy.ndimage import gaussian_filter
from scipy.interpolate import RBFInterpolator

import cartopy.crs as ccrs
import cartopy.feature as cfeature
from PIL import Image
# map



"""
Preparing the data
"""
df = pd.read_csv("all_month.csv")
# read the csv file into a pandas dataframe

x1 = np.linspace(df["latitude"].min(), df["latitude"].max(), 100)
y1 = np.linspace(df["longitude"].min(), df["longitude"].max(), 100)
# creaates evenly spaced values between the min and max of latitude and longitude, with the number of values equal to the number of unique values in each column

x2, y2 = np.meshgrid(x1, y1)



"""
Create the figure and axes
"""
fig = plt.figure(000, figsize = (12, 8))
# creating the overall canvas
# 000 is an identifier for the figure, can be any number

ax = fig.add_subplot(111, projection = "3d")
# adding a 3D subplot to the figure
# can also be written as, fig.add_subplot(nrows=2, ncols=2, index=1, projection='3d')
# indexes for matplotlib is 1 based, not 0 based, as they follow the MATLAB convention



"""
Smoothing (to make up for not being able to use cubic interpolation with this piece of data)
"""
points = np.column_stack((df['latitude'], df['longitude']))
values = df['mag'].values

rbf = RBFInterpolator(points, values, kernel='gaussian', epsilon=2)
z2_smooth = rbf(np.column_stack((x2.ravel(), y2.ravel()))).reshape(x2.shape)
# smooth interpolation using RBFInterpolator

z2 = griddata((df['latitude'], df['longitude']), df['mag'], (x2, y2), method = "linear") # Interpolate the magnitude data onto the grid (gives value, the magnitude, to the array shaped by x2 y2) using cubic interpolation

z2_smooth = gaussian_filter(z2, sigma=1)



"""
Plot
"""
ax.plot_surface(x2, y2, z2_smooth, rstride=1, cstride=1, cmap = "viridis", edgecolor='none', antialiased=True)



"""
Add filled contours
"""
# 2D contour footprint of the 3D heights/topography

z2_filled = np.nan_to_num(z2, nan=df['mag'].mean())

contour = ax.contourf(x2, y2, z2_smooth, zdir='z', offset=0, cmap=cm.viridis, antialiased=False)
# extrapolated values to form a square base



"""
Stylize
"""
rcParams['legend.fontsize'] = 20

rc('text', usetex=True) # use LaTeX to write all text in the figure
rc('axes', linewidth=2) # set the axes linewidth to 2
rc('font', weight='bold', size=14) # set the font to bold and size 14

ax.set_title("Earthquakes in the Past Month", fontsize=24, pad=20, weight='bold')
ax.set_xlabel("Latitude", fontsize=10, labelpad=20, weight='medium')
ax.set_ylabel("Longitude", fontsize=10, labelpad=20, weight='medium')
ax.set_zlabel("Magnitude", fontsize=10, labelpad=20, weight='medium')

ax.set_xlim(df['latitude'].min(), df['latitude'].max())
ax.set_ylim(df['longitude'].min(), df['longitude'].max())
ax.set_zlim(0, df['mag'].max() * 0.8)

ax.view_init(elev=30, azim=60)  # elev = vertical angle, azim = horizontal angle



"""

ax = fig.add_subplot(111, projection=ccrs.PlateCarree())
# make a separate 2D map as the 'floor'

ax.set_extent([df["longitude"].min()*0.7, df["longitude"].max()*0.7, df["latitude"].min()*0.7, df["latitude"].max()*0.7])
# set an extent to the data's bounding box, zoomed in slightly

ax.add_feature(cfeature.LAND, facecolor='lightgray')
ax.add_feature(cfeature.OCEAN, facecolor='lightblue')
ax.add_feature(cfeature.COASTLINE)
ax.add_feature(cfeature.BORDERS, linestyle=':')

Cartopy Map (2D) # 2D map, doesn't work
"""



"""
Map
"""

img = plt.imread("World-Continents-Topographic-map-Lowres.png")

img_small = img[::20, ::20]  # take every 20th pixel

lon_min, lon_max = df["longitude"].min(), df["longitude"].max()
lat_min, lat_max = df["latitude"].min(), df["latitude"].max()

"""
x_img = np.linspace(lon_min, lon_max, img_small.shape[1])
y_img = np.linspace(lat_min, lat_max, img_small.shape[0])
x_img, y_img = np.meshgrid(x_img, y_img)

ax.plot_surface(x_img, y_img, np.ones_like(x_img) * -0.5, rstride=1, cstride=1, facecolors=img_small/255, shade=False)

"""
ax.set_box_aspect([abs(lat_max-lat_min), abs(lon_max-lon_min), 100])



"""
Show
"""
# ax.scatter(df["latitude"], df["longitude"], df["mag"], c=df["mag"], cmap="viridis", marker='o')

plt.show()
fig.savefig("EarthQuakes_PastMonth_Areas_Meshgrid.png", dpi=300)



"""
Debug
"""
print("latitude is= ", df["latitude"].sort_values())
print("longitude is= ", df["longitude"].sort_values())
# print(np.isnan(z2).sum(), "points are NaN out of", z2.size)

